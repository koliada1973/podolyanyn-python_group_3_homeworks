# Task 1:
# Спільний лічильник
# Створіть клас з іменем Counter і зробіть його підкласом класу Thread у модулі Threading.
# Створіть у класі дві глобальні змінні, одна з яких називається counter і має значення 0, а інша - rounds - 100.000.
# Тепер реалізуйте метод run(), нехай він містить простий цикл for, який повторюється через rounds (тобто 100.000 разів)
# і кожного разу збільшує значення лічильника на 1.
# Створіть 2 екземпляри потоку і запустіть їх, потім об'єднайте їх і перевірте результат лічильника, він повинен бути 200.000, правильно?
# Запустіть його кілька разів і розгляньте різні причини, чому ви отримуєте саме таку відповідь.

import threading

class Counter(threading.Thread):
    counter = 0
    rounds = 100000

    # Наступний атрібют екземпляру класу потрібен тільки
    # для роботи з версією Python старіше 3.13:
    # def __init__(self):
    #     self.lock = threading.Lock()

    def run(self):
        for i in range(0, self.rounds):
            # self.lock.acquire() # (для версій Python старіше 3.13) - тепер тільки цей поток має доступ до ресурсів (до змінної self.counter)
            self.counter += 1
            # self.lock.release() # (для версій Python старіше 3.13) - зняття блокування


new_counter = Counter()

t1 = threading.Thread(target=new_counter.run)
t2 = threading.Thread(target=new_counter.run)

t1.start()
t2.start()

t1.join()
t2.join()

result = new_counter.counter
print(result)

# Отримуємо в результаті 200000, тому що використовуємо версію Python 3.13.
# В старіших версіях Python ми отримали б непередбачуваний результат (але менше ніж 200000),
# тому що доступ до змінної класу counter був би не синхронізованим.
#
# І поки один потік збільшує значення counter - інший потік розраховує нове значення,
# що базується на ще попередньому (не збільшеному) значенні counter.
# В результаті розраховане попереднім потоком значення, може бути замінене на результат розрахунку наступного потоку
# (тобто перекреслює результат роботи попереднього потоку)...
#
# Щоб вирішити цю проблему, потрібно було б використовувати threading.Lock(),
# який гарантує, що в кожен окремий момент тільки один потік має доступ до змінної.