# Task 2:
# Прочитати про Fibonacci search та імплементуйте його за допомогою Python.
# Визначте складність алгоритму та порівняйте його з бінарним пошуком

# Довідкова інформація (ChatGPT):
# Пошук Фібоначчі – це спосіб швидко знайти потрібний елемент у відсортованому списку,
# використовуючи числа Фібоначчі (1, 1, 2, 3, 5, 8, 13...).

# Як це працює в загальних рисах:
# Маємо відсортований список (наприклад: [2, 5, 8, 12, 17, 23, 31, 45]).
# Беремо найбільше число Фібоначчі, яке не перевищує довжину списку.
# Розділяємо список на частини за допомогою цього числа.
# Дивимося в середину потрібної частини.
# Якщо знайшли – добре. Якщо ні – відкидаємо частину списку і знову ділимо, використовуючи менші числа Фібоначчі.
# Тобто ідея така ж, як у бінарному пошуку (де ми постійно ділимо навпіл), тільки замість "половин" використовуються числа Фібоначчі для поділу.

def fibonacci(n):
    """Функція розрахунку n-ного числа Фібоначчі (рекурсівна)"""
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

def max_fib(max):
    """Функція розрахунку числа Фібоначчі, що не перевершує максимум"""
    n = 1 # початкове значення
    # В циклі послідовно розраховуємо n-не число Фібоначчі:
    while True:
        f = fibonacci(n)
        if f > max:
            # І якщо воно вже більше, ніж заданий максимум, то повертаємо попереднє значення n
            return fibonacci(n - 1)
        else:
            # Інакше - збільшуємо n
            n += 1

def fib_search(new_list, value, min: int =None, max: int =None) -> int:
    """Функція пошуку за алгоритмом Фібоначчі (рекурсивна)"""
    min = 0 if min is None else min
    max = len(new_list) if max is None else max
    # Поточний фрагмент new_list (використовуємо зріз списку, а не відкидання зайвих частин):
    list_slice = new_list[min:max]
    # число Фібоначчі, що не перевершує довжину поточного фрагмента new_list
    fib = max_fib(len(list_slice))-1
    # Значення поточного елементу new_list
    x = list_slice[fib]
    if x == value:
        # Якщо value знайдено - повертаємо індекс його знаходження в new_list
        return fib + min
    elif fib == 0:
        # fib == 0 значить, що між min та max більше немає інших елементів,
        # тобто value на знайдено - повертаємо -1
        return -1
    else:
        # Якщо поточне значення меньше шуканого, то збільшуємо min і переходимо на наступний рекурсивний цикл
        if x < value:
            min = fib + min
            return fib_search(new_list, value, min, max)

        # Якщо поточне значення більше шуканого, то зменьшуємо max і переходимо на наступний рекурсивний цикл
        elif x > value:
            max = fib + min
            return fib_search(new_list, value, min, max)


# Використання:
if __name__ == '__main__':
    list1 = [1,3,4,7,11,23,33,45,77,88]
    print(fib_search(list1,23))         # 5
    print(fib_search(list1, 1))         # 0
    print(fib_search(list1, 88))        # 9
    print(fib_search(list1, 5))         # -1
    print(fib_search(list1, 100))       # -1
    print(fib_search(list1, -10))             # -1

    # Порівняння алгоритмів пошуку Fibonacci з бінарним пошуком:
    # Тестовий список значень:
    test_list = [i for i in range(1000)]    # В цьому списку значення відповідає його позиції

    import time
    # Пошук числа 577 за допомогою алгоритма пошуку Fibonacci:
    start = time.time()
    print(f"Позиція числа 577 в списку (пошук Fibonacci) = {fib_search(test_list, 577)}")
    finish = time.time()
    print(f"Delta time = {finish - start:0.6f} seconds")

    from Task1 import binary_recursive_search
    # Пошук числа 577 за допомогою алгоритма бінарного пошуку:
    start = time.time()
    print(f"Позиція числа 577 в списку (бінарний пошук) = {binary_recursive_search(test_list, 577)}")
    finish = time.time()
    print(f"Delta time = {finish - start:0.6f} seconds")

# Складність алгоритму пошуку Fibonacci дорівнює О(log n), тому що з кожним кроком діапазон пошуку зменшується.
# Обидва алгоритма реалізовані як рекурсивні функції.
# Але складність алгоритму пошуку Fibonacci більша, ніж алгоритму бінарного пошуку і час виконання значно відрізняється.
# Це пояснюється більшою складністю розрахунку числа Фібоначчі для великих значень n
# - (на початковому етапі виконання пошуку, поки діапазон пошуку ще широкий).