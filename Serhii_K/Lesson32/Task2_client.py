import socket
from Task2_Caesar import Caesar_cipher

if __name__ == "__main__":
    while True:
        # Запитуємо у користувача ключ та текст повідомлення,
        # де перші символм- це знак ключа (кількість шагів сдвигу),
        # і дали після крапки - текст повідомлення
        user_answer = input("""Введіть ключ-повідомлення:
        перші символи- це кількість шагів сдвигу (наприклад, -2 або 7),
        і дали після крапки - текст повідомлення
        наприклад "-5.СЛОВО"
        (q - зупинка клієнта та сервера)------------> """)

        HOST = '127.0.0.1'
        PORT = 65432

        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((HOST, PORT))
            # Відправка даних до сервера:
            if user_answer == 'q':
                s.sendall('stop_server'.encode('utf-8'))
                print("Закриття клієнта та сервера...")
                quit()
            else:
                # Зберігаємо ключ та текст для перевірки:
                # Положення розділяючої крапки. Якщо її немає - введено неправильні дані
                # Можна розділити рядок на ключ та повідомлення через user_answer.split('.'), але я зроблю це через індекс крапки:
                try:
                    x = user_answer.index(".")
                except:
                    print('Перевірте введені дані!')
                    continue

                key = user_answer[:x]          # Ключ (сдвиг)
                text = user_answer[(x + 1):]   # Текст повідомлення, що має шифруватись

                # Відправка повідомлення на сервер:
                message = user_answer.encode("utf-8")
                s.sendall(message)

            # Отримання повідомлення від сервера:
            data = s.recv(1024).decode('UTF-8')

        print('Отримане зашифроване повідомлення:', repr(data))
        # Перевірка повідомлення на правильність шифрування.
        # Тобто робимо зворотнє шифрування з від'ємним ключем:
        print('Перевірка повідомлення: ', Caesar_cipher(-int(key), data, ))
